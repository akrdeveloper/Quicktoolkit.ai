<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quicktoolkit</title>
    <meta name="description" content="Quicktoolkit offers 20+ free, responsive, and easy-to-use online tools including image converters, calculators, text utilities, and more. All client-side.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Design Theme & Aesthetic */
            --background-color: #1E1E2F; /* dark navy */
            --text-color: #6d75cb; /* light gray */
            --header-background: #2B2D42; /* deep blue */
            --accent-color: #26be98; /* gold */
            --tool-card-background: #3A3D5B; /* dark grayish-blue */
            --button-hover-color: #00e6a9;
            --soft-box-shadow: 0 8px 16px rgba(255, 215, 0, 0.1);
            --card-hover-box-shadow: 0 12px 24px rgba(89, 248, 3, 0.2);
            --font-family: 'Poppins', sans-serif;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: var(--font-family); background-color: var(--background-color); color: var(--text-color); line-height: 1.6; min-height: 100vh; }
        header { background-color: var(--header-background); color: var(--accent-color); padding: 2rem 1rem; text-align: center; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); margin-bottom: 2rem; }
        header h1 { font-weight: 700; font-size: 2.8rem; }
        main { max-width: 1200px; margin: 0 auto; padding: 0 1rem; }
        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; padding-bottom: 2rem; }
        
        .tool-card { background-color: var(--tool-card-background); padding: 1.5rem; border-radius: 10px; box-shadow: var(--soft-box-shadow); transition: transform 0.3s ease, background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease; display: flex; flex-direction: column; justify-content: space-between; min-height: 200px; }
        .tool-card:hover { transform: translateY(-5px); background-color: var(--accent-color); color: var(--background-color); box-shadow: var(--card-hover-box-shadow); }
        .tool-card:hover h2, .tool-card:hover p { color: var(--background-color); }
        .tool-card h2 { font-size: 1.5rem; margin-bottom: 0.5rem; color: var(--text-color); transition: color 0.3s ease; }
        .tool-card p { font-size: 0.9rem; margin-bottom: 1rem; flex-grow: 1; opacity: 0.8; transition: color 0.3s ease, opacity 0.3s ease; }

        .tool-button { background-color: var(--accent-color); color: var(--background-color); border: none; padding: 0.75rem 1.25rem; border-radius: 5px; font-weight: bold; cursor: pointer; text-align: center; transition: background-color 0.3s ease; align-self: flex-start; min-width: 120px; }
        .tool-button:hover { background-color: var(--button-hover-color); }

        /* Modal & UI Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.7); animation: fadeIn 0.3s ease-in-out; }
        .modal-content { background-color: var(--header-background); margin: 5% auto; padding: 25px; border-radius: 10px; width: 90%; max-width: 700px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); animation: slideIn 0.3s ease-in-out; }
        .close-button { color: var(--text-color); float: right; font-size: 28px; font-weight: bold; transition: color 0.2s ease; cursor: pointer; }
        .close-button:hover { color: var(--accent-color); }
        .modal-body { margin-top: 1.5rem; }
        .modal-body input:not([type="checkbox"]):not([type="range"]), .modal-body select, .modal-body textarea { width: 100%; padding: 0.75rem; margin-bottom: 1rem; border-radius: 5px; border: 1px solid var(--tool-card-background); background-color: var(--background-color); color: var(--text-color); font-size: 1rem; }
        .modal-body textarea { min-height: 100px; resize: vertical; font-family: 'Poppins', sans-serif; }
        .modal-body label { display: block; margin-bottom: 0.5rem; font-weight: 600; }
        .modal-body .result-area { margin-top: 1rem; padding: 1rem; background-color: var(--background-color); border-radius: 5px; border: 1px solid var(--tool-card-background); white-space: pre-wrap; word-wrap: break-word; }
        .modal-alert { margin-top: 1rem; padding: 0.75rem; border-radius: 5px; font-weight: bold; }
        .modal-alert.error { background-color: #dc3545; color: rgb(43, 255, 110); }
        .modal-alert.success { background-color: #28a796; color: rgb(43, 255, 110); }
        
        .color-picker-display { display: flex; align-items: center; margin-top: 1rem; }
        .color-picker-display .color-preview { width: 50px; height: 50px; border-radius: 5px; margin-right: 1rem; border: 1px solid var(--text-color); }
        .timer-display, .stopwatch-display { font-size: 2.5rem; font-weight: bold; text-align: center; margin-bottom: 1rem; color: var(--accent-color); }
        .tabs { display: flex; margin-bottom: 1rem; border-bottom: 1px solid var(--tool-card-background); }
        .tab-button { background: none; border: none; color: var(--text-color); padding: 0.75rem 1rem; cursor: pointer; font-size: 1rem; font-family: var(--font-family); transition: background-color 0.3s, color 0.3s; }
        .tab-button.active { background-color: var(--accent-color); color: var(--background-color); border-bottom: 2px solid var(--accent-color); font-weight: bold; }
        .laps-list { max-height: 150px; overflow-y: auto; border: 1px solid var(--tool-card-background); padding: 0.5rem; margin-top: 1rem; }
        .laps-list li { list-style: none; padding: 0.25rem 0; border-bottom: 1px dashed var(--tool-card-background); }
        #jsonInput, #jsonOutput { font-family: monospace; }
        
        /* Specific Cropper Styles for Interactive UI */
        #cropCanvas { border: 2px solid #FFD700; background-color: var(--background-color); }


        /* Media Queries */
        @media (max-width: 992px) { .tool-grid { grid-template-columns: repeat(2, 1fr); } header h1 { font-size: 2.2rem; } }
        @media (max-width: 600px) { .tool-grid { grid-template-columns: 1fr; } .modal-content { margin: 10% auto; padding: 15px; } header h1 { font-size: 2rem; } }
        /* Animations */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>
    <header>
        <h1>Quicktoolkit</h1>
    </header>

    <main>
        <div class="tool-grid" id="toolGrid"></div>
    </main>

    <div id="toolModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalBtn">&times;</span>
            <h2 id="modalTitle">Tool Title</h2>
            <div id="modalBody" class="modal-body"></div>
            <div id="modalAlert" class="modal-alert" style="display:none;"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const toolGrid = document.getElementById('toolGrid');
            const modal = document.getElementById('toolModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            const modalAlert = document.getElementById('modalAlert');
            const closeButton = document.getElementById('closeModalBtn');
            let currentToolCleanup = null;

            // --- Utility Functions ---
            function showAlert(message, type = 'info') {
                modalAlert.textContent = message;
                modalAlert.className = `modal-alert ${type}`;
                modalAlert.style.display = 'block';
            }
            function hideAlert() { modalAlert.style.display = 'none'; }
            function openModal(tool) {
                if (currentToolCleanup) currentToolCleanup();
                modalTitle.textContent = tool.title;
                modalBody.innerHTML = '';
                hideAlert();
                const toolFunction = toolInitializers[tool.id];
                currentToolCleanup = toolFunction ? toolFunction(modalBody) : () => {};
                modal.style.display = 'block';
            }
            function closeModal() {
                modal.style.display = 'none';
                if (currentToolCleanup) currentToolCleanup();
                currentToolCleanup = null;
            }
            closeButton.onclick = closeModal;
            window.onclick = (event) => { if (event.target === modal) closeModal(); };

            // Audio Utility (Shared by 5 and 6)
            const audioUtils = (() => {
                const context = new (window.AudioContext || window.webkitAudioContext)();
                function bufferToWave(abuffer) {
                    let numOfChan = abuffer.numberOfChannels,
                        length = abuffer.length * numOfChan * 2 + 44,
                        buffer = new ArrayBuffer(length), view = new DataView(buffer),
                        channels = [], pos = 0; 

                    view.setUint32(pos, 0x46464952, false); pos += 4; // "RIFF"
                    view.setUint32(pos, length - 8, true); pos += 4; view.setUint32(pos, 0x45564157, false); pos += 4; // "WAVE"
                    view.setUint32(pos, 0x20746d66, false); pos += 4; // "fmt " chunk
                    view.setUint32(pos, 16, true); pos += 4; view.setUint16(pos, 1, true); pos += 2; 
                    view.setUint16(pos, numOfChan, true); pos += 2; view.setUint32(pos, abuffer.sampleRate, true); pos += 4;
                    view.setUint32(pos, abuffer.sampleRate * 2 * numOfChan, true); pos += 4; 
                    view.setUint16(pos, numOfChan * 2, true); pos += 2; view.setUint16(pos, 16, true); pos += 2; 

                    view.setUint32(pos, 0x61746164, false); pos += 4; // "data" - chunk
                    view.setUint32(pos, abuffer.length * numOfChan * 2, true); pos += 4; 

                    for (let i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
                    for (let offset = 0; offset < abuffer.length; offset++) {
                        for (let i = 0; i < numOfChan; i++) {
                            let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                            sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                            view.setInt16(pos, sample, true); pos += 2;
                        }
                    }
                    return new Blob([view], { type: 'audio/wav' });
                }
                return { context, bufferToWave };
            })();
            
            // --- Tool Definitions ---
            const tools = [
                { id: 'imageConverter', title: 'Image Converter', description: 'Convert between JPG, PNG, and WEBP formats.' },
                { id: 'imageCompressor', title: 'Image Compressor', description: 'Compress image file size with quality settings.' },
                { id: 'imageCropper', title: 'Image Cropper', description: 'Upload, crop image with preview, and export.' },
                { id: 'videoConverter', title: 'Video Converter', description: 'Convert video (MP4 â†” WebM via MediaRecorder).'},
                { id: 'audioConverter', title: 'Audio Converter', description: 'Convert uploaded audio to WAV format.' },
                { id: 'audioTrimmer', title: 'Audio Trimmer', description: 'Upload, trim audio, and export trimmed WAV clip.' },
                { id: 'ageCalculator', title: 'Age Calculator', description: 'Calculate exact age from date of birth.' },
                { id: 'emiCalculator', title: 'EMI Calculator', description: 'Calculate Equated Monthly Installment for loans.' },
                { id: 'sipCalculator', title: 'SIP Calculator', description: 'Calculate future value of SIP investments.' },
                { id: 'qrCodeGenerator', title: 'QR Code Generator', description: 'Generate downloadable QR codes from text/URL.' },
                { id: 'passwordGenerator', title: 'Password Generator', description: 'Generate secure passwords with custom options.' },
                { id: 'wordCounter', title: 'Word Counter', description: 'Count words, characters, and estimate reading time.' },
                { id: 'base64EncoderDecoder', title: 'Base64 Encoder/Decoder', description: 'Encode/decode plain text to/from Base64.' },
                { id: 'colorPicker', title: 'Color Picker Tool', description: 'Pick colors and get HEX, RGB, HSL values.' },
                { id: 'textToSpeech', title: 'Text to Speech', description: 'Convert text into spoken audio using browser voices.' },
                { id: 'speechToText', title: 'Speech to Text', description: 'Convert voice from microphone into text (Experimental).' },
                { id: 'jsonFormatter', title: 'JSON Formatter', description: 'Format and validate JSON data.' },
                { id: 'unitConverter', title: 'Unit Converter', description: 'Convert values between various units (length, weight, temp).' },
                { id: 'bmiCalculator', title: 'BMI Calculator', description: 'Calculate Body Mass Index and category.' },
                { id: 'timerStopwatch', title: 'Timer / Stopwatch', description: 'Simple timer and stopwatch functionality.' },
            ];

            // --- Tool Initializers (Each returns a cleanup function) ---
            const toolInitializers = {
                imageConverter: (container) => {
                    container.innerHTML = `<input type="file" id="imgConvFile" accept="image/jpeg,image/png,image/webp"><label for="imgConvFormat">Convert to:</label><select id="imgConvFormat"><option value="image/jpeg">JPEG</option><option value="image/png">PNG</option><option value="image/webp">WEBP</option></select><button id="imgConvButton">Convert & Download</button><img id="imagePreview" src="#" alt="Preview" style="max-width:100%; max-height:300px; margin-top:10px; display:none;">`;
                    const [fileInput, formatSelect, convertButton, preview] = ['imgConvFile', 'imgConvFormat', 'imgConvButton', 'imagePreview'].map(id => container.querySelector(`#${id}`));
                    let originalFileName = 'converted_image'; let blobUrl = null;
                    fileInput.onchange = (e) => {
                        if (!e.target.files.length) return; originalFileName = e.target.files[0].name.split('.')[0] || 'image';
                        if (blobUrl) URL.revokeObjectURL(blobUrl); blobUrl = URL.createObjectURL(e.target.files[0]); preview.src = blobUrl; preview.style.display = 'block'; hideAlert();
                    };
                    convertButton.onclick = () => {
                        if (!fileInput.files.length) { showAlert('Select an image.', 'error'); return; }
                        const [targetFormat, targetExtension] = [formatSelect.value, formatSelect.value.split('/')[1].replace('jpeg', 'jpg')];
                        showAlert('Processing...', 'info');

                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height;
                            canvas.getContext('2d').drawImage(img, 0, 0);
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a'); a.href = url; a.download = `${originalFileName}_converted.${targetExtension}`;
                                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                                    showAlert('Conversion successful!', 'success');
                                } else { showAlert(`Error converting to ${targetFormat}.`, 'error'); }
                            }, targetFormat, 0.9);
                        };
                        img.onerror = () => showAlert('Could not load image.', 'error');
                        img.src = preview.src; // Use the object URL for faster loading
                    };
                    return () => { if (blobUrl) URL.revokeObjectURL(blobUrl); };
                },
                imageCompressor: (container) => {
                    container.innerHTML = `<input type="file" id="imgCompFile" accept="image/jpeg,image/png"><label for="imgCompQuality">JPEG Quality (0.1 - 1.0):</label><input type="range" id="imgCompQuality" value="0.7" min="0.1" max="1.0" step="0.05" style="width:100%;"><span id="qualityValue">0.7</span><button id="imgCompButton">Compress & Download</button><p>PNG uses lossless compression (quality ignored).</p><div id="compressionInfo" class="result-area" style="display:none;"></div><img id="imagePreviewComp" src="#" alt="Preview" style="max-width:100%; max-height:300px; margin-top:10px; display:none;">`;
                    const [fileInput, qualityInput, qualityValue, compressButton, info, preview] = ['imgCompFile', 'imgCompQuality', 'qualityValue', 'imgCompButton', 'compressionInfo', 'imagePreviewComp'].map(id => container.querySelector(`#${id}`));
                    let originalFile = null; let blobUrl = null;
                    qualityInput.oninput = () => qualityValue.textContent = parseFloat(qualityInput.value).toFixed(2);
                    fileInput.onchange = (e) => {
                        if (!e.target.files.length) return; originalFile = e.target.files[0];
                        if (blobUrl) URL.revokeObjectURL(blobUrl); blobUrl = URL.createObjectURL(originalFile); preview.src = blobUrl;
                        preview.style.display = 'block'; info.style.display = 'none'; hideAlert();
                    };
                    compressButton.onclick = () => {
                        if (!originalFile) { showAlert('Select an image.', 'error'); return; }
                        const quality = parseFloat(qualityInput.value);
                        showAlert('Processing...', 'info');

                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height;
                            canvas.getContext('2d').drawImage(img, 0, 0);
                            const outputFormat = originalFile.type === 'image/png' ? 'image/png' : 'image/jpeg';
                            const extension = outputFormat.split('/')[1].replace('jpeg', 'jpg');

                            canvas.toBlob((blob) => {
                                if (blob) {
                                    const [origSize, compSize] = [(originalFile.size / 1024), (blob.size / 1024)];
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a'); a.href = url; a.download = `${originalFile.name.split('.')[0]}_compressed.${extension}`;
                                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                                    info.innerHTML = `Original: ${origSize.toFixed(2)} KB<br>Compressed: ${compSize.toFixed(2)} KB<br>Reduction: ${((1 - compSize / origSize) * 100).toFixed(2)}%`;
                                    info.style.display = 'block'; showAlert('Compression successful!', 'success');
                                } else { showAlert('Error during compression.', 'error'); }
                            }, outputFormat, outputFormat === 'image/jpeg' ? quality : undefined);
                        };
                        img.src = blobUrl;
                    };
                    return () => { if (blobUrl) URL.revokeObjectURL(blobUrl); };
                },
                imageCropper: (container) => {
                    container.innerHTML = `<input type="file" id="imgCropFile" accept="image/*"><p>Select image and define crop area (pixels).</p><canvas id="cropCanvas" style="display:none; cursor: crosshair;"></canvas><div style="display:flex; flex-wrap:wrap; gap:10px; margin-top:1rem;"><div><label for="cropX">X:</label><input type="number" id="cropX" value="0" style="width:70px; display:inline-block;"></div><div><label for="cropY">Y:</label><input type="number" id="cropY" value="0" style="width:70px; display:inline-block;"></div><div><label for="cropW">W:</label><input type="number" id="cropW" value="100" style="width:70px; display:inline-block;"></div><div><label for="cropH">H:</label><input type="number" id="cropH" value="100" style="width:70px; display:inline-block;"></div></div><button id="cropButton" style="margin-top:1rem;">Crop & Download</button><img id="croppedImagePreview" src="#" alt="Cropped Preview" style="max-width:100%; max-height:300px; margin-top:10px; display:none;">`;
                    const [fileInput, canvas, xInput, yInput, wInput, hInput, cropButton, preview] = ['imgCropFile', 'cropCanvas', 'cropX', 'cropY', 'cropW', 'cropH', 'cropButton', 'croppedImagePreview'].map(id => container.querySelector(`#${id}`));
                    const ACCENT_COLOR = '#FFD700'; // Using hex to fix canvas stroke issue
                    let sourceImage = null; let imgScale = 1; let cropRect = { x: 0, y: 0, w: 0, h: 0 };
                    let isDrawing = false; let originalFile = null; let startX, startY;

                    const draw = () => {
                        if (!sourceImage) return;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);
                        
                        const scaledCrop = {
                            x: cropRect.x / imgScale, y: cropRect.y / imgScale,
                            w: cropRect.w / imgScale, h: cropRect.h / imgScale
                        };
                        
                        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.clearRect(scaledCrop.x, scaledCrop.y, scaledCrop.w, scaledCrop.h);
                        
                        ctx.strokeStyle = ACCENT_COLOR;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(scaledCrop.x, scaledCrop.y, scaledCrop.w, scaledCrop.h);
                    };

                    const updateInputsFromRect = () => { [xInput.value, yInput.value, wInput.value, hInput.value] = [cropRect.x, cropRect.y, cropRect.w, cropRect.h].map(v => Math.round(v / imgScale)); };
                    const updateRectFromInputs = () => {
                        cropRect = {
                            x: parseInt(xInput.value) * imgScale, y: parseInt(yInput.value) * imgScale,
                            w: parseInt(wInput.value) * imgScale, h: parseInt(hInput.value) * imgScale
                        };
                        draw();
                    };

                    const getMousePos = (e) => { const rect = canvas.getBoundingClientRect(); return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) }; };

                    canvas.addEventListener('mousedown', (e) => {
                        isDrawing = true; const pos = getMousePos(e); startX = pos.x; startY = pos.y;
                        cropRect = { x: pos.x * imgScale, y: pos.y * imgScale, w: 0, h: 0 };
                        updateInputsFromRect(); draw();
                    });
                    canvas.addEventListener('mousemove', (e) => {
                        if (!isDrawing) return; const pos = getMousePos(e);
                        cropRect.w = Math.abs((pos.x - startX) * imgScale); cropRect.h = Math.abs((pos.y - startY) * imgScale);
                        cropRect.x = Math.min(startX, pos.x) * imgScale; cropRect.y = Math.min(startY, pos.y) * imgScale;
                        
                        // Clamping
                        cropRect.x = Math.max(0, Math.min(cropRect.x, sourceImage.width - cropRect.w));
                        cropRect.y = Math.max(0, Math.min(cropRect.y, sourceImage.height - cropRect.h));

                        updateInputsFromRect(); draw();
                    });
                    canvas.addEventListener('mouseup', () => { isDrawing = false; draw(); });

                    [xInput, yInput, wInput, hInput].forEach(input => input.oninput = updateRectFromInputs);

                    fileInput.onchange = (e) => {
                        if (!e.target.files.length) return; originalFile = e.target.files[0];
                        const reader = new FileReader(); reader.onload = (event) => {
                            sourceImage = new Image(); sourceImage.onload = () => {
                                const MAX_PREVIEW_DIM = 400; const [w, h] = [sourceImage.width, sourceImage.height];
                                const ratio = Math.min(MAX_PREVIEW_DIM / w, MAX_PREVIEW_DIM / h, 1);
                                canvas.width = w * ratio; canvas.height = h * ratio;
                                canvas.style.display = 'block'; preview.style.display = 'none'; imgScale = w / canvas.width; 
                                
                                // Reset crop to default
                                cropRect = { x: w * 0.25, y: h * 0.25, w: w * 0.5, h: h * 0.5 };
                                updateInputsFromRect(); draw();
                                showAlert('Image loaded. Click and drag or set dimensions (pixels).', 'info');
                            }; sourceImage.src = event.target.result;
                        }; reader.readAsDataURL(originalFile);
                    };

                    cropButton.onclick = () => {
                        const [sx, sy, sw, sh] = [xInput, yInput, wInput, hInput].map(i => parseInt(i.value));
                        if (!sourceImage || sw <= 0 || sh <= 0) { showAlert('Define a valid crop area.', 'error'); return; }
                        showAlert('Cropping...', 'info');
                        const finalCanvas = document.createElement('canvas'); finalCanvas.width = sw; finalCanvas.height = sh;
                        finalCanvas.getContext('2d').drawImage(sourceImage, sx, sy, sw, sh, 0, 0, sw, sh);
                        const dataUrl = finalCanvas.toDataURL(originalFile.type || 'image/png');
                        preview.src = dataUrl; preview.style.display = 'block';
                        const a = document.createElement('a'); a.href = dataUrl; a.download = `cropped.${(originalFile.type || 'image/png').split('/')[1].replace('jpeg', 'jpg')}`;
                        document.body.appendChild(a); a.click(); document.body.removeChild(a); showAlert('Image cropped and downloaded.', 'success');
                    };
                    return () => { canvas.style.display = 'none'; preview.style.display = 'none'; };
                },
                videoConverter: (container) => {
                    container.innerHTML = `<p>This tool re-encodes a video using your browser's MediaRecorder, converting it to a selected format (WebM is widely supported). The process can be slow and quality depends heavily on browser implementation.</p><input type="file" id="vidConvFile" accept="video/*"><label for="vidConvFormat">Convert to MIME Type:</label><select id="vidConvFormat"><option value="video/webm;codecs=vp8,opus">WebM (VP8/Opus)</option><option value="video/webm;codecs=vp9,opus">WebM (VP9/Opus)</option><option value="video/mp4;codecs=avc1.42E01E,mp4a.40.2">MP4 (H.264/AAC - Unreliable)</option></select><button id="vidConvButton">Convert & Download</button><video id="vidConvPreview" controls style="max-width:100%; margin-top:10px; display:none; background-color:black;"></video><p id="vidConvStatus" class="result-area" style="display:none;"></p>`;
                    const [fileInput, formatSelect, convertButton, videoPreview, statusP] = ['vidConvFile', 'vidConvFormat', 'vidConvButton', 'vidConvPreview', 'vidConvStatus'].map(id => container.querySelector(`#${id}`));
                    let mediaRecorder = null; let recordedChunks = []; let originalFileName = 'converted_video'; let previewUrl = null;
                    fileInput.onchange = (e) => {
                        recordedChunks = []; if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); if (previewUrl) URL.revokeObjectURL(previewUrl);
                        if (!e.target.files.length) return; originalFileName = e.target.files[0].name.split('.')[0] || 'video';
                        previewUrl = URL.createObjectURL(e.target.files[0]); videoPreview.src = previewUrl; videoPreview.style.display = 'block';
                        videoPreview.onloadedmetadata = () => showAlert(`Video loaded. Duration: ${videoPreview.duration.toFixed(2)}s.`, 'info');
                    };
                    convertButton.onclick = () => {
                        if (!videoPreview.src || !videoPreview.src.startsWith('blob:')) { showAlert('Select video file.', 'error'); return; }
                        const targetMimeType = formatSelect.value;
                        if (!MediaRecorder.isTypeSupported(targetMimeType)) { showAlert(`Browser won't record to ${targetMimeType}. Try WebM.`, 'error'); return; }

                        showAlert('Starting conversion... Do not close modal while video plays.', 'info'); statusP.textContent = 'Conversion in progress... 0%'; statusP.style.display = 'block'; videoPreview.currentTime = 0;
                        const stream = videoPreview.captureStream(); recordedChunks = []; mediaRecorder = new MediaRecorder(stream, { mimeType: targetMimeType });
                        
                        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                        mediaRecorder.onstop = () => {
                            if (recordedChunks.length === 0) { showAlert('Conversion failed: No data recorded.', 'error'); statusP.textContent = 'Conversion failed.'; return; }
                            const blob = new Blob(recordedChunks, { type: targetMimeType.split(';')[0] });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a'); a.href = url; a.download = `${originalFileName}_converted.${targetMimeType.split('/')[1].split(';')[0].replace('webm', 'webm').replace('mp4', 'mp4')}`;
                            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                            showAlert('Video conversion finished!', 'success'); statusP.textContent = 'Complete.';
                        };
                        videoPreview.onended = () => { if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop(); };
                        videoPreview.ontimeupdate = () => { if (videoPreview.duration && mediaRecorder && mediaRecorder.state === 'recording') { statusP.textContent = `Progress: ${(videoPreview.currentTime / videoPreview.duration * 100).toFixed(0)}%`; } };
                        videoPreview.play().then(() => mediaRecorder.start(1000)).catch(err => showAlert(`Error: ${err.message}`, 'error'));
                    };
                    return () => { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); if (videoPreview) videoPreview.pause(); if (previewUrl) URL.revokeObjectURL(previewUrl); };
                },
                audioConverter: (container) => {
                    container.innerHTML = `<p>Converts playable audio files to uncompressed WAV format.</p><input type="file" id="audioConvFile" accept="audio/*"><button id="audioConvButton">Convert to WAV & Download</button><audio id="audioConvPreview" controls style="width:100%; margin-top:10px; display:none;"></audio>`;
                    const [fileInput, convertButton, audioPreview] = ['audioConvFile', 'audioConvButton', 'audioConvPreview'].map(id => container.querySelector(`#${id}`));
                    let decodedAudioBuffer = null; let originalFileName = 'converted_audio'; let previewUrl = null;
                    fileInput.onchange = (e) => {
                        if (!e.target.files.length) return; originalFileName = e.target.files[0].name.split('.')[0] || 'audio'; showAlert('Loading audio...', 'info');
                        const reader = new FileReader(); reader.onload = (event) => {
                            audioUtils.context.decodeAudioData(event.target.result).then(buffer => {
                                decodedAudioBuffer = buffer;
                                if (previewUrl) URL.revokeObjectURL(previewUrl); previewUrl = URL.createObjectURL(e.target.files[0]);
                                audioPreview.src = previewUrl; audioPreview.style.display = 'block'; showAlert('Audio loaded.', 'success');
                            }).catch(err => showAlert(`Error decoding: ${err.message}. Try another format.`, 'error'));
                        }; reader.readAsArrayBuffer(e.target.files[0]);
                    };
                    convertButton.onclick = () => {
                        if (!decodedAudioBuffer) { showAlert('Load an audio file first.', 'error'); return; }
                        try {
                            const wavBlob = audioUtils.bufferToWave(decodedAudioBuffer);
                            const url = URL.createObjectURL(wavBlob);
                            const a = document.createElement('a'); a.href = url; a.download = `${originalFileName}_converted.wav`;
                            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                            showAlert('Conversion to WAV successful!', 'success');
                        } catch (err) { showAlert(`Error converting: ${err.message}`, 'error'); }
                    };
                    return () => { if (previewUrl) URL.revokeObjectURL(previewUrl); audioPreview.style.display = 'none'; };
                },
                audioTrimmer: (container) => {
                    container.innerHTML = `<p>Upload an audio file to trim and export a segment as a WAV file.</p><input type="file" id="trimAudioFile" accept="audio/*"><audio id="trimAudioPreview" controls style="width:100%; margin-top:10px; display:none;"></audio><div id="trimControls" style="display:none; margin-top:10px;"><p id="audioDurationInfo" style="font-weight:bold;"></p><label for="trimStartTime">Start Time (s):</label><input type="number" id="trimStartTime" value="0" min="0" step="0.01"><label for="trimEndTime">End Time (s):</label><input type="number" id="trimEndTime" value="0" min="0" step="0.01"><button id="trimButton">Trim & Download WAV</button></div>`;
                    const [fileInput, audioPreview, trimControls, startTimeInput, endTimeInput, durationInfo, trimButton] = ['trimAudioFile', 'trimAudioPreview', 'trimControls', 'trimStartTime', 'trimEndTime', 'audioDurationInfo', 'trimButton'].map(id => container.querySelector(`#${id}`));
                    let sourceBuffer = null; let originalFileName = 'trimmed_audio'; let previewUrl = null;
                    fileInput.onchange = (e) => {
                        if (!e.target.files.length) return; originalFileName = e.target.files[0].name.split('.')[0] || 'audio'; showAlert('Loading audio...', 'info');
                        const reader = new FileReader(); reader.onload = (event) => {
                            audioUtils.context.decodeAudioData(event.target.result).then(decodedBuffer => {
                                sourceBuffer = decodedBuffer; if (previewUrl) URL.revokeObjectURL(previewUrl);
                                previewUrl = URL.createObjectURL(e.target.files[0]); audioPreview.src = previewUrl; audioPreview.style.display = 'block';
                                audioPreview.oncanplaythrough = () => URL.revokeObjectURL(previewUrl);
                                const duration = sourceBuffer.duration; durationInfo.textContent = `Total Duration: ${duration.toFixed(2)}s`;
                                [endTimeInput.value, endTimeInput.max, startTimeInput.max] = [duration.toFixed(2), duration.toFixed(2), duration.toFixed(2)];
                                trimControls.style.display = 'block'; showAlert('Audio loaded. Set trim times.', 'success');
                            }).catch(err => { showAlert(`Error decoding: ${err.message}`, 'error'); trimControls.style.display = 'none'; });
                        }; reader.readAsArrayBuffer(e.target.files[0]);
                    };
                    trimButton.onclick = () => {
                        if (!sourceBuffer) { showAlert('Load audio file.', 'error'); return; }
                        const [start, end] = [parseFloat(startTimeInput.value), parseFloat(endTimeInput.value)];
                        if (isNaN(start) || isNaN(end) || start < 0 || end <= start || end > sourceBuffer.duration) { showAlert('Invalid start/end times.', 'error'); return; }
                        try {
                            showAlert('Trimming audio...', 'info');
                            const [startOffset, endOffset] = [Math.floor(start * sourceBuffer.sampleRate), Math.floor(end * sourceBuffer.sampleRate)];
                            const trimmedBuffer = audioUtils.context.createBuffer(sourceBuffer.numberOfChannels, endOffset - startOffset, sourceBuffer.sampleRate);
                            for (let i = 0; i < sourceBuffer.numberOfChannels; i++) { trimmedBuffer.getChannelData(i).set(sourceBuffer.getChannelData(i).subarray(startOffset, endOffset)); }
                            const wavBlob = audioUtils.bufferToWave(trimmedBuffer);
                            const url = URL.createObjectURL(wavBlob);
                            const a = document.createElement('a'); a.href = url; a.download = `${originalFileName}_trimmed.wav`;
                            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                            showAlert('Audio trimmed and downloaded!', 'success');
                        } catch (err) { showAlert(`Error trimming: ${err.message}`, 'error'); }
                    };
                    return () => { if (previewUrl) URL.revokeObjectURL(previewUrl); trimControls.style.display = 'none'; audioPreview.style.display = 'none'; };
                },
                ageCalculator: (container) => {
                    container.innerHTML = `<label for="birthDate">Enter Date of Birth:</label><input type="date" id="birthDate"><button id="calculateAgeBtn">Calculate Age</button><div id="ageResult" class="result-area" style="display:none;"></div>`;
                    const [dateInput, calcBtn, resultDiv] = ['birthDate', 'calculateAgeBtn', 'ageResult'].map(id => container.querySelector(`#${id}`));
                    calcBtn.onclick = () => {
                        const birthDate = new Date(dateInput.value); const today = new Date();
                        if (!dateInput.value || birthDate > today) { showAlert('Enter a valid past date.', 'error'); resultDiv.style.display = 'none'; return; }
                        let [y, m, d] = [today.getFullYear() - birthDate.getFullYear(), today.getMonth() - birthDate.getMonth(), today.getDate() - birthDate.getDate()];
                        if (d < 0) { m--; d += new Date(today.getFullYear(), today.getMonth(), 0).getDate(); }
                        if (m < 0) { y--; m += 12; }
                        resultDiv.innerHTML = `You are: <br><strong>${y}</strong> years, <strong>${m}</strong> months, and <strong>${d}</strong> days old.`;
                        resultDiv.style.display = 'block'; hideAlert();
                    };
                    return () => {};
                },
                emiCalculator: (container) => {
                    container.innerHTML = `<label for="loanAmount">Loan Amount (â‚¹):</label><input type="number" id="loanAmount" placeholder="e.g., 100000" min="1"><label for="interestRate">Annual Interest Rate (%):</label><input type="number" id="interestRate" placeholder="e.g., 10.5" min="0" step="0.01"><label for="loanTenure">Loan Tenure (months):</label><input type="number" id="loanTenure" placeholder="e.g., 12" min="1"><button id="calculateEmiBtn">Calculate EMI</button><div id="emiResult" class="result-area" style="display:none;"></div>`;
                    const [amountInput, rateInput, tenureInput, calcBtn, resultDiv] = ['loanAmount', 'interestRate', 'loanTenure', 'calculateEmiBtn', 'emiResult'].map(id => container.querySelector(`#${id}`));
                    calcBtn.onclick = () => {
                        const [P, annualRate, N] = [amountInput, rateInput, tenureInput].map(i => parseFloat(i.value));
                        if (isNaN(P) || isNaN(annualRate) || isNaN(N) || P <= 0 || annualRate < 0 || N <= 0) { showAlert('Enter valid numbers.', 'error'); resultDiv.style.display = 'none'; return; }
                        let EMI;
                        if (annualRate === 0) { EMI = P / N; } else { const r = annualRate / (12 * 100); EMI = (P * r * Math.pow(1 + r, N)) / (Math.pow(1 + r, N) - 1); }
                        if (!isFinite(EMI)) { showAlert('Calculation invalid.', 'error'); resultDiv.style.display = 'none'; return; }
                        const [totalPayment, totalInterest] = [EMI * N, (EMI * N) - P];
                        resultDiv.innerHTML = `Monthly EMI: <strong>â‚¹${EMI.toFixed(2)}</strong><br>Total Interest: <strong>â‚¹${totalInterest.toFixed(2)}</strong><br>Total Payment: <strong>â‚¹${totalPayment.toFixed(2)}</strong>`;
                        resultDiv.style.display = 'block'; hideAlert();
                    };
                    return () => {};
                },
                sipCalculator: (container) => {
                    container.innerHTML = `<label for="monthlyInvestment">Monthly Investment (â‚¹):</label><input type="number" id="monthlyInvestment" placeholder="e.g., 5000" min="1"><label for="expectedReturnRate">Annual Return Rate (%):</label><input type="number" id="expectedReturnRate" placeholder="e.g., 12" min="0" step="0.01"><label for="investmentDuration">Investment Duration (years):</label><input type="number" id="investmentDuration" placeholder="e.g., 10" min="1"><button id="calculateSipBtn">Calculate Future Value</button><div id="sipResult" class="result-area" style="display:none;"></div>`;
                    const [PInput, rateInput, durationInput, calcBtn, resultDiv] = ['monthlyInvestment', 'expectedReturnRate', 'investmentDuration', 'calculateSipBtn', 'sipResult'].map(id => container.querySelector(`#${id}`));
                    calcBtn.onclick = () => {
                        const [P, annualRate, t_years] = [PInput, rateInput, durationInput].map(i => parseFloat(i.value));
                        if (isNaN(P) || isNaN(annualRate) || isNaN(t_years) || P <= 0 || annualRate < 0 || t_years <= 0) { showAlert('Enter valid positive numbers.', 'error'); resultDiv.style.display = 'none'; return; }
                        const [n, i] = [t_years * 12, annualRate / 12 / 100];
                        let M = (i === 0) ? P * n : P * (((Math.pow(1 + i, n) - 1) / i) * (1 + i));
                        if (!isFinite(M)) { showAlert('Calculation invalid.', 'error'); resultDiv.style.display = 'none'; return; }
                        const [totalInvestment, wealthGained] = [P * n, M - (P * n)];
                        resultDiv.innerHTML = `Total Invested: <strong>â‚¹${totalInvestment.toFixed(2)}</strong><br>Estimated Returns: <strong>â‚¹${wealthGained.toFixed(2)}</strong><br>Future Value: <strong>â‚¹${M.toFixed(2)}</strong>`;
                        resultDiv.style.display = 'block'; hideAlert();
                    };
                    return () => {};
                },
                qrCodeGenerator: (container) => {
                    // Placeholder as external library integration is complex and disallowed for the final solution.
                    container.innerHTML = `<label for="qrText">Text or URL:</label><textarea id="qrText" placeholder="Enter text here"></textarea><label for="qrSize">Size (pixels):</label><input type="number" id="qrSize" value="250" min="50" max="500"><button id="generateQrBtn">Generate Placeholder</button><div id="qrCodeContainer" class="result-area" style="text-align:center; padding:10px; background-color:white;"><canvas id="qrCanvas" style="border: 5px solid var(--accent-color);"></canvas></div><button id="downloadQrBtn" style="margin-top:1rem;">Download Image</button>`;
                    const [textInput, sizeInput, generateBtn, qrCanvas, downloadBtn] = ['qrText', 'qrSize', 'generateQrBtn', 'qrCanvas', 'downloadQrBtn'].map(id => container.querySelector(`#${id}`));
                    const ctx = qrCanvas.getContext('2d');
                    const drawPlaceholder = (text, size) => {
                        qrCanvas.width = size; qrCanvas.height = size; ctx.fillStyle = 'white'; ctx.fillRect(0, 0, size, size);
                        ctx.fillStyle = '#1E1E2F'; ctx.font = `${size / 20}px ${getComputedStyle(document.body).fontFamily}`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillRect(size*0.1, size*0.1, size*0.2, size*0.2); ctx.fillRect(size*0.7, size*0.1, size*0.2, size*0.2);
                        ctx.fillText(text.substring(0, 30) + (text.length > 30 ? '...' : ''), size / 2, size / 2);
                        showAlert('QR placeholder drawn. Real QR functionality requires a library.', 'info');
                    };
                    generateBtn.onclick = () => drawPlaceholder(textInput.value.trim(), parseInt(sizeInput.value));
                    downloadBtn.onclick = () => {
                        const a = document.createElement('a'); a.href = qrCanvas.toDataURL('image/png'); a.download = 'qrcode.png';
                        document.body.appendChild(a); a.click(); document.body.removeChild(a); showAlert('Image downloaded!', 'success');
                    };
                    drawPlaceholder("Quicktoolkit", 250);
                    return () => {};
                },
                passwordGenerator: (container) => {
                    container.innerHTML = `<label for="passLength">Password Length:</label><input type="number" id="passLength" value="16" min="8" max="128"><div class="option-group"><input type="checkbox" id="incUppercase" checked> <label for="incUppercase">Uppercase (A-Z)</label><br><input type="checkbox" id="incLowercase" checked> <label for="incLowercase">Lowercase (a-z)</label><br><input type="checkbox" id="incNumbers" checked> <label for="incNumbers">Numbers (0-9)</label><br><input type="checkbox" id="incSymbols" checked> <label for="incSymbols">Symbols (!@#$%^&*)</label></div><button id="generatePassBtn">Generate Password</button><div class="result-area" style="margin-top:1rem; display:flex; align-items:center;"><input type="text" id="generatedPassword" readonly style="flex-grow:1; margin-right:10px;"><button id="copyPassBtn" title="Copy to Clipboard" style="padding: 0.5em 0.8em;">ðŸ“‹</button></div>`;
                    const [lengthInput, ucCheck, lcCheck, numCheck, symCheck, generateBtn, output, copyBtn] = ['passLength', 'incUppercase', 'incLowercase', 'incNumbers', 'incSymbols', 'generatePassBtn', 'generatedPassword', 'copyPassBtn'].map(id => container.querySelector(`#${id}`));
                    const charSets = { u: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', l: 'abcdefghijklmnopqrstuvwxyz', n: '0123456789', s: '!@#$%^&*()_+-=[]{}|;:,.<>?' };
                    const generate = () => {
                        const length = parseInt(lengthInput.value); let [charset, guaranteed] = ['', ''];
                        if (ucCheck.checked) { charset += charSets.u; guaranteed += charSets.u.charAt(Math.floor(Math.random() * charSets.u.length)); }
                        if (lcCheck.checked) { charset += charSets.l; guaranteed += charSets.l.charAt(Math.floor(Math.random() * charSets.l.length)); }
                        if (numCheck.checked) { charset += charSets.n; guaranteed += charSets.n.charAt(Math.floor(Math.random() * charSets.n.length)); }
                        if (symCheck.checked) { charset += charSets.s; guaranteed += charSets.s.charAt(Math.floor(Math.random() * charSets.s.length)); }
                        if (charset === '' || length < guaranteed.length) { showAlert('Select types and ensure length > selected types.', 'error'); return; }
                        let password = guaranteed;
                        for (let i = guaranteed.length; i < length; i++) { password += charset.charAt(Math.floor(Math.random() * charset.length)); }
                        output.value = password.split('').sort(() => 0.5 - Math.random()).join(''); hideAlert();
                    };
                    generateBtn.onclick = generate;
                    copyBtn.onclick = () => { if (output.value) navigator.clipboard.writeText(output.value).then(() => showAlert('Copied!', 'success')).catch(() => showAlert('Failed to copy.', 'error')); };
                    generate();
                    return () => {};
                },
                wordCounter: (container) => {
                    container.innerHTML = `<textarea id="wcText" placeholder="Paste or type your text here..." rows="8"></textarea><div id="wcResult" class="result-area">Words: <strong id="wcWords">0</strong> | Chars (No Spaces): <strong id="wcCharsNoSpaces">0</strong><br>Chars (With Spaces): <strong id="wcCharsWithSpaces">0</strong> | Spaces: <strong id="wcSpaces">0</strong><br>Sentences: <strong id="wcSentences">0</strong> | Paragraphs: <strong id="wcParagraphs">0</strong><br>Reading Time: <strong id="wcReadingTime">~0 min</strong></div>`;
                    const [textArea, wordsSpan, cwsSpan, cnsSpan, spacesSpan, sentencesSpan, paragraphsSpan, readingTimeSpan] = ['wcText', 'wcWords', 'wcCharsWithSpaces', 'wcCharsNoSpaces', 'wcSpaces', 'wcSentences', 'wcParagraphs', 'wcReadingTime'].map(id => container.querySelector(`#${id}`));
                    textArea.oninput = () => {
                        const [text, trimmedText] = [textArea.value, textArea.value.trim()];
                        const words = trimmedText.match(/\b\S+\b/g)?.length || 0;
                        const [cws, cns] = [text.length, text.replace(/\s/g, '').length];
                        const sentences = trimmedText.match(/[^.!?]+[.!?]+(\s|$)/g)?.length || (trimmedText ? 1 : 0);
                        const paragraphs = trimmedText ? trimmedText.split(/\n\s*\n/).filter(p => p.trim() !== '').length : 0;
                        const readingTimeMinutes = words / 200;
                        const readingTimeText = (words === 0) ? '~0 min' : (readingTimeMinutes < 1 ? `~${Math.round(readingTimeMinutes * 60)} sec` : `~${Math.ceil(readingTimeMinutes)} min`);
                        
                        [wordsSpan.textContent, cwsSpan.textContent, cnsSpan.textContent, spacesSpan.textContent, sentencesSpan.textContent, paragraphsSpan.textContent, readingTimeSpan.textContent] = 
                        [words, cws, cns, cws - cns, sentences, paragraphs, readingTimeText];
                    };
                    return () => {};
                },
                base64EncoderDecoder: (container) => {
                    container.innerHTML = `<textarea id="b64Input" placeholder="Enter text to encode or Base64 to decode" rows="5"></textarea><button id="b64EncodeBtn">Encode to Base64</button><button id="b64DecodeBtn">Decode from Base64</button><label for="b64Output" style="margin-top:1rem;">Result:</label><textarea id="b64Output" readonly rows="5"></textarea>`;
                    const [inputArea, outputArea, encodeBtn, decodeBtn] = ['b64Input', 'b64Output', 'b64EncodeBtn', 'b64DecodeBtn'].map(id => container.querySelector(`#${id}`));
                    const toBase64 = (str) => btoa(unescape(encodeURIComponent(str)));
                    const fromBase64 = (str) => decodeURIComponent(escape(atob(str)));
                    encodeBtn.onclick = () => { try { outputArea.value = toBase64(inputArea.value); showAlert('Encoded!', 'success'); } catch (e) { outputArea.value = ''; showAlert('Encoding Error.', 'error'); } };
                    decodeBtn.onclick = () => { try { outputArea.value = fromBase64(inputArea.value); showAlert('Decoded!', 'success'); } catch (e) { outputArea.value = 'Error: Invalid Base64.'; showAlert('Decoding Error.', 'error'); } };
                    return () => {};
                },
                colorPicker: (container) => {
                    container.innerHTML = `<label for="htmlColorPicker">Select a Color:</label><input type="color" id="htmlColorPicker" value="#FFD700" style="width:100%; height: 40px; margin-bottom:1rem;"><div class="color-picker-display result-area"><div id="colorPreview" class="color-preview" style="background-color: var(--accent-color);"></div><div id="colorValues" class="color-values"><p>HEX: <strong id="hexValue">#FFD700</strong> <button class="copy-color-val" data-value-target="#hexValue" title="Copy HEX" style="padding:0.2em 0.5em; margin-left:5px;">ðŸ“‹</button></p><p>RGB: <strong id="rgbValue">rgb(255, 215, 0)</strong> <button class="copy-color-val" data-value-target="#rgbValue" title="Copy RGB" style="padding:0.2em 0.5em; margin-left:5px;">ðŸ“‹</button></p><p>HSL: <strong id="hslValue">hsl(51, 100%, 50%)</strong> <button class="copy-color-val" data-value-target="#hslValue" title="Copy HSL" style="padding:0.2em 0.5em; margin-left:5px;">ðŸ“‹</button></p></div></div>`;
                    const [picker, preview, hexS, rgbS, hslS] = ['htmlColorPicker', 'colorPreview', 'hexValue', 'rgbValue', 'hslValue'].map(id => container.querySelector(`#${id}`));
                    const hexToRgb = (hex) => { const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => r + r + g + g + b + b)); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0}; };
                    const rgbToHsl = (r, g, b) => { r /= 255; g /= 255; b /= 255; const [max, min] = [Math.max(r, g, b), Math.min(r, g, b)]; let [h, s, l] = [0, 0, (max + min) / 2]; if (max !== min) { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) }; };
                    const updateValues = (hex) => {
                        const rgb = hexToRgb(hex); const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                        preview.style.backgroundColor = hex; hexS.textContent = hex.toUpperCase(); rgbS.textContent = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`; hslS.textContent = `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
                    };
                    picker.oninput = (e) => updateValues(e.target.value);
                    container.querySelectorAll('.copy-color-val').forEach(btn => {
                        btn.onclick = () => { const targetSpan = container.querySelector(btn.dataset.valueTarget); navigator.clipboard.writeText(targetSpan.textContent).then(() => showAlert('Copied!', 'success')).catch(() => showAlert('Failed to copy.', 'error')); };
                    });
                    updateValues(picker.value);
                    return () => {};
                },
                textToSpeech: (container) => {
                    container.innerHTML = `<p>Uses your browser's speech synthesizer. Voices vary by device.</p><textarea id="ttsText" placeholder="Enter text to speak..." rows="6">Hello, this is Quicktoolkit's text-to-speech utility.</textarea><div class="option-group"><label for="ttsVoice">Voice:</label><select id="ttsVoice"></select><div style="margin-top: 10px;"><label for="ttsRate">Rate: <span id="ttsRateVal">1.0</span></label><input type="range" id="ttsRate" min="0.5" max="2" value="1.0" step="0.1" style="width: 100%;"></div><div style="margin-top: 10px;"><label for="ttsPitch">Pitch: <span id="ttsPitchVal">1.0</span></label><input type="range" id="ttsPitch" min="0" max="2" value="1.0" step="0.1" style="width: 100%;"></div></div><button id="ttsSpeakBtn">Speak</button><button id="ttsPauseBtn" disabled>Pause</button><button id="ttsResumeBtn" disabled>Resume</button><button id="ttsStopBtn" disabled>Stop</button>`;
                    const [textInput, voiceSelect, rateInput, pitchInput, speakBtn, pauseBtn, resumeBtn, stopBtn, rateValSpan, pitchValSpan] = ['ttsText', 'ttsVoice', 'ttsRate', 'ttsPitch', 'ttsSpeakBtn', 'ttsPauseBtn', 'ttsResumeBtn', 'ttsStopBtn', 'ttsRateVal', 'ttsPitchVal'].map(id => container.querySelector(`#${id}`));
                    const synth = window.speechSynthesis; if (!synth) { container.innerHTML = "<p>Sorry, your browser doesn't support Text to Speech.</p>"; return () => {}; }
                    let voices = []; let currentUtterance = null;
                    const populateVoices = () => {
                        voices = synth.getVoices().sort((a,b) => a.name.localeCompare(b.name));
                        voiceSelect.innerHTML = voices.map(v => `<option value="${v.name}" ${v.default ? 'selected' : ''}>${v.name} (${v.lang})</option>`).join('');
                    };
                    if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = populateVoices; else populateVoices();
                    rateInput.oninput = () => rateValSpan.textContent = parseFloat(rateInput.value).toFixed(1);
                    pitchInput.oninput = () => pitchValSpan.textContent = parseFloat(pitchInput.value).toFixed(1);
                    const handleEnd = () => { speakBtn.disabled = false; pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true; currentUtterance = null; hideAlert(); };
                    speakBtn.onclick = () => {
                        if (synth.speaking) synth.cancel(); if (textInput.value.trim() === '') { showAlert('Enter text.', 'error'); return; }
                        currentUtterance = new SpeechSynthesisUtterance(textInput.value.trim());
                        currentUtterance.voice = voices.find(v => v.name === voiceSelect.value);
                        currentUtterance.pitch = parseFloat(pitchInput.value); currentUtterance.rate = parseFloat(rateInput.value);
                        currentUtterance.onstart = () => { showAlert('Speaking...', 'info'); speakBtn.disabled = true; pauseBtn.disabled = false; stopBtn.disabled = false; };
                        currentUtterance.onend = handleEnd; currentUtterance.onerror = (e) => { showAlert(`Error: ${e.error}`, 'error'); handleEnd(); };
                        synth.speak(currentUtterance);
                    };
                    pauseBtn.onclick = () => { if(synth.speaking && !synth.paused) { synth.pause(); pauseBtn.disabled = true; resumeBtn.disabled = false; showAlert('Paused.', 'info'); } };
                    resumeBtn.onclick = () => { if(synth.paused) { synth.resume(); pauseBtn.disabled = false; resumeBtn.disabled = true; showAlert('Speaking...', 'info'); } };
                    stopBtn.onclick = () => { if(synth.speaking || synth.paused) synth.cancel(); handleEnd(); };
                    return () => { if (synth && (synth.speaking || synth.paused)) synth.cancel(); };
                },
                speechToText: (container) => {
                    container.innerHTML = `<p>Uses your browser's Web Speech API. **Requires microphone access** and is highly browser/OS dependent.</p><button id="sttStartBtn">Start Listening</button><button id="sttStopBtn" disabled>Stop Listening</button><textarea id="sttOutput" placeholder="Transcript will appear here..." rows="6"></textarea>`;
                    const [startBtn, stopBtn, outputArea] = ['sttStartBtn', 'sttStopBtn', 'sttOutput'].map(id => container.querySelector(`#${id}`));
                    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SR) { container.innerHTML = '<p>Speech Recognition is not supported.</p>'; return () => {}; }
                    const recognition = new SR(); recognition.continuous = true; recognition.interimResults = true; recognition.lang = navigator.language || 'en-US';
                    let finalTranscript = '';
                    recognition.onstart = () => { startBtn.disabled = true; stopBtn.disabled = false; showAlert('Listening...', 'info'); };
                    recognition.onend = () => { startBtn.disabled = false; stopBtn.disabled = true; if (finalTranscript.trim()) showAlert('Stopped listening.', 'success'); };
                    recognition.onerror = (e) => { showAlert(`Error: ${e.error}. Try a different browser.`, 'error'); startBtn.disabled = false; stopBtn.disabled = true; };
                    recognition.onresult = (e) => {
                        let interim = '';
                        for (let i = e.resultIndex; i < e.results.length; ++i) { if (e.results[i].isFinal) finalTranscript += e.results[i][0].transcript + ' '; else interim += e.results[i][0].transcript; }
                        outputArea.value = finalTranscript + interim;
                    };
                    startBtn.onclick = () => { finalTranscript = ''; outputArea.value = ''; try { recognition.start(); } catch (e) { if (e.name === 'InvalidStateError') recognition.stop(); showAlert('Attempting to restart listening...', 'info'); } };
                    stopBtn.onclick = () => recognition.stop();
                    return () => { try { recognition.stop(); } catch(e){} };
                },
                jsonFormatter: (container) => {
                    container.innerHTML = `<textarea id="jsonInput" placeholder="Paste your JSON data here..." rows="7"></textarea><div style="display:flex; align-items:center; margin-bottom:1rem; gap: 10px;"><label for="jsonSpaces" style="margin-bottom:0; width:100px;">Indentation:</label><select id="jsonSpaces" style="width:120px; margin-bottom:0;"><option value="2">2 Spaces</option><option value="4" selected>4 Spaces</option><option value="tab">Tabs</option><option value="0">Minified</option></select><button id="formatJsonBtn" style="margin-left:auto;">Format JSON</button></div><label for="jsonOutput" style="display:flex; justify-content:space-between;">Formatted JSON: <button id="copyJsonBtn" style="padding:0.3em 0.6em; margin-top:-5px;">ðŸ“‹</button></label><textarea id="jsonOutput" readonly rows="7" style="font-family: monospace;"></textarea>`;
                    const [inputArea, outputArea, formatBtn, copyBtn, spacesSelect] = ['jsonInput', 'jsonOutput', 'formatJsonBtn', 'copyJsonBtn', 'jsonSpaces'].map(id => container.querySelector(`#${id}`));
                    formatBtn.onclick = () => {
                        const jsonString = inputArea.value.trim(); if (!jsonString) { showAlert('Paste JSON data.', 'info'); outputArea.value = ''; return; }
                        try {
                            const jsonObj = JSON.parse(jsonString);
                            let indent = (spacesSelect.value === 'tab') ? '\t' : (parseInt(spacesSelect.value) === 0 ? null : parseInt(spacesSelect.value));
                            outputArea.value = JSON.stringify(jsonObj, null, indent);
                            showAlert('Formatted successfully!', 'success');
                        } catch (e) { outputArea.value = 'Error: Invalid JSON\n\n' + e.message; showAlert('Invalid JSON.', 'error'); }
                    };
                    copyBtn.onclick = () => { if (outputArea.value && !outputArea.value.startsWith('Error:')) navigator.clipboard.writeText(outputArea.value).then(() => showAlert('Copied!', 'success')).catch(() => showAlert('Failed to copy.', 'error')); };
                    return () => {};
                },
                unitConverter: (container) => {
                    const units = {
                        length: { name: "Length", items: { meter: 1, kilometer: 1000, foot: 0.3048, inch: 0.0254 } },
                        weight: { name: "Weight/Mass", items: { kilogram: 1, gram: 0.001, pound: 0.45359237, ounce: 0.0283495231 } },
                        temperature: { name: "Temperature", items: { celsius: 'celsius', fahrenheit: 'fahrenheit', kelvin: 'kelvin' } }
                    };
                    container.innerHTML = `<label for="ucCategory">Category:</label><select id="ucCategory"></select><div style="display:flex; gap:10px; margin-top:10px; align-items:flex-end;"><div style="flex:2"><label for="ucInputValue">Value:</label><input type="number" id="ucInputValue" value="1" step="any"></div><div style="flex:3"><label for="ucFromUnit">From:</label><select id="ucFromUnit"></select></div><div style="font-size:1.5rem; padding-bottom:0.5rem;">â‡„</div><div style="flex:3"><label for="ucToUnit">To:</label><select id="ucToUnit"></select></div></div><div id="ucResult" class="result-area" style="text-align:center;">Enter values and see result here</div>`;
                    const [categorySelect, fromUnitSelect, toUnitSelect, valueInput, resultDiv] = ['ucCategory', 'ucFromUnit', 'ucToUnit', 'ucInputValue', 'ucResult'].map(id => container.querySelector(`#${id}`));

                    const populateUnitOptions = (key) => {
                        const unitSet = units[key].items; [fromUnitSelect, toUnitSelect].forEach(select => select.innerHTML = Object.keys(unitSet).map((u, i) => `<option value="${u}" ${i === 1 && Object.keys(unitSet).length > 1 ? 'selected' : ''}>${u.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</option>`).join(''));
                    };
                    const convert = () => {
                        const [key, from, to, val] = [categorySelect.value, fromUnitSelect.value, toUnitSelect.value, parseFloat(valueInput.value)];
                        if (isNaN(val)) { resultDiv.textContent = 'Invalid input.'; return; } let result;
                        if (key === 'temperature') {
                            let baseC;
                            if (from === 'celsius') baseC = val; else if (from === 'fahrenheit') baseC = (val - 32) * 5/9; else if (from === 'kelvin') baseC = val - 273.15;
                            if (to === 'celsius') result = baseC; else if (to === 'fahrenheit') result = (baseC * 9/5) + 32; else if (to === 'kelvin') result = baseC + 273.15;
                        } else { const baseValue = val * units[key].items[from]; result = baseValue / units[key].items[to]; }
                        if (typeof result === 'undefined' || !isFinite(result)) { resultDiv.textContent = 'Error in conversion.'; return; }
                        const precision = Math.abs(result) > 100 ? 2 : 4;
                        resultDiv.textContent = `${val} ${fromUnitSelect.options[fromUnitSelect.selectedIndex].text} = ${result.toFixed(precision)} ${toUnitSelect.options[toUnitSelect.selectedIndex].text}`;
                    };
                    
                    Object.keys(units).forEach(key => { const opt = document.createElement('option'); opt.value = key; opt.textContent = units[key].name; categorySelect.appendChild(opt); });
                    [categorySelect, fromUnitSelect, toUnitSelect, valueInput].forEach(elem => elem.oninput = convert);
                    populateUnitOptions(categorySelect.value); convert();
                    return () => {};
                },
                bmiCalculator: (container) => {
                    container.innerHTML = `<label for="bmiWeight">Weight (kg):</label><input type="number" id="bmiWeight" placeholder="e.g., 70" min="1"><label for="bmiHeight">Height (cm):</label><input type="number" id="bmiHeight" placeholder="e.g., 175" min="10"><button id="calculateBmiBtn">Calculate BMI</button><div id="bmiResult" class="result-area" style="text-align:center;"></div>`;
                    const [weightInput, heightInput, calcBtn, resultDiv] = ['bmiWeight', 'bmiHeight', 'calculateBmiBtn', 'bmiResult'].map(id => container.querySelector(`#${id}`));
                    calcBtn.onclick = () => {
                        const [weight, heightCm] = [weightInput, heightInput].map(i => parseFloat(i.value));
                        if (isNaN(weight) || isNaN(heightCm) || weight <= 0 || heightCm <= 0) { showAlert('Enter valid kg and cm values.', 'error'); return; }
                        const [heightM, bmi] = [heightCm / 100, weight / (heightCm * heightCm) * 10000];
                        let category, color;
                        if (bmi < 18.5) { category = 'Underweight'; color = '#3498db'; } else if (bmi < 24.9) { category = 'Normal weight'; color = '#2ecc71'; } else if (bmi < 29.9) { category = 'Overweight'; color = '#f1c40f'; } else if (bmi < 34.9) { category = 'Obesity Class I'; color = '#e67e22'; } else if (bmi < 39.9) { category = 'Obesity Class II'; color = '#e74c3c'; } else { category = 'Obesity Class III (Severe)'; color = '#c0392b'; }
                        resultDiv.innerHTML = `Your BMI: <strong style="font-size:1.5em; color: ${color};">${bmi.toFixed(2)}</strong><br>Category: <strong style="color:${color};">${category}</strong>`;
                        resultDiv.style.display = 'block'; hideAlert();
                    };
                    return () => {};
                },
                timerStopwatch: (container) => {
                    container.innerHTML = `<div class="tabs"><button class="tab-button active" data-tab="timerTab">Timer</button><button class="tab-button" data-tab="stopwatchTab">Stopwatch</button></div><div id="timerTab" class="tab-content" style="padding-top:1rem;"><h3>Timer</h3><div style="display:flex; justify-content:space-around; margin-bottom:1rem;"><div><label>Hours:</label><br><input type="number" id="timerHours" min="0" max="99" value="0" style="width:70px;"></div><div><label>Mins:</label><br><input type="number" id="timerMinutes" min="0" max="59" value="5" style="width:70px;"></div><div><label>Secs:</label><br><input type="number" id="timerSeconds" min="0" max="59" value="0" style="width:70px;"></div></div><div class="timer-display" id="timerDisplay">00:05:00</div><div style="text-align:center;"><button id="timerStart">Start</button><button id="timerPause" disabled>Pause</button><button id="timerReset">Reset</button></div></div><div id="stopwatchTab" class="tab-content" style="display:none; padding-top:1rem;"><h3>Stopwatch</h3><div class="stopwatch-display" id="stopwatchDisplay">00:00.00</div><div style="text-align:center; margin-bottom:1rem;"><button id="stopwatchStart">Start</button><button id="stopwatchStop" disabled>Stop</button><button id="stopwatchLap" disabled>Lap</button><button id="stopwatchReset" disabled>Reset</button></div><ul id="lapsList" class="laps-list"></ul></div>`;
                    const [hIn, mIn, sIn, tDisp, tStart, tPause, tReset] = ['timerHours', 'timerMinutes', 'timerSeconds', 'timerDisplay', 'timerStart', 'timerPause', 'timerReset'].map(id => container.querySelector(`#${id}`));
                    const [swDisp, swStart, swStop, swLap, swReset, lapsList] = ['stopwatchDisplay', 'stopwatchStart', 'stopwatchStop', 'stopwatchLap', 'stopwatchReset', 'lapsList'].map(id => container.querySelector(`#${id}`));
                    let [tInt, tSec, tRun] = [null, 300, false]; let [swInt, swStartT, swElapsed, swRun, lapNum] = [null, 0, 0, false, 1];
                    const formatT = (s) => { const [h, m] = [Math.floor(s / 3600), Math.floor((s % 3600) / 60)]; s %= 60; return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; };
                    const setTFromIn = () => { tSec = (parseInt(hIn.value) || 0) * 3600 + (parseInt(mIn.value) || 0) * 60 + (parseInt(sIn.value) || 0); tDisp.textContent = formatT(tSec); };
                    const resetT = (d = true) => { clearInterval(tInt); tRun = false; hideAlert(); if (d) [hIn, mIn, sIn].forEach(i => i.value = (i.id.includes('Minutes') ? 5 : 0)); setTFromIn(); tStart.disabled = false; tPause.disabled = true; [hIn, mIn, sIn].forEach(i => i.disabled = false); };
                    tStart.onclick = () => { if (tRun) return; setTFromIn(); if (tSec <= 0) { showAlert('Set duration > 0.', 'error'); return; } tRun = true; tStart.disabled = true; tPause.disabled = false; [hIn, mIn, sIn].forEach(i => i.disabled = true); tInt = setInterval(() => { if (tSec-- > 0) tDisp.textContent = formatT(tSec); else { clearInterval(tInt); tDisp.textContent = "Time's Up!"; showAlert("Timer finished!", "success"); resetT(false); } }, 1000); };
                    tPause.onclick = () => { clearInterval(tInt); tRun = false; tStart.disabled = false; tPause.disabled = true; [hIn, mIn, sIn].forEach(i => i.disabled = false); }; tReset.onclick = () => resetT(true);
                    [hIn, mIn, sIn].forEach(i => i.oninput = () => { if (!tRun) setTFromIn(); });
                    
                    const formatSW = (ms) => { const [m, s, cs] = [Math.floor(ms / 60000), Math.floor((ms % 60000) / 1000), Math.floor((ms % 1000) / 10)]; return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`; };
                    const resetSW = (fromTab = false) => { clearInterval(swInt); swElapsed = 0; lapNum = 1; swRun = false; swDisp.textContent = formatSW(0); swStart.disabled = false; swStop.disabled = true; swLap.disabled = true; swReset.disabled = true; if (!fromTab) lapsList.innerHTML = ''; };
                    swStart.onclick = () => { if (swRun) return; swRun = true; swStartT = Date.now() - swElapsed; swInt = setInterval(() => { swElapsed = Date.now() - swStartT; swDisp.textContent = formatSW(swElapsed); }, 10); swStart.disabled = true; swStop.disabled = false; swLap.disabled = false; swReset.disabled = false; hideAlert(); };
                    swStop.onclick = () => { clearInterval(swInt); swRun = false; swStart.disabled = false; swStop.disabled = true; swLap.disabled = false; };
                    swLap.onclick = () => { if (swElapsed > 0) { const li = document.createElement('li'); li.textContent = `Lap ${lapNum++}: ${formatSW(swElapsed)}`; lapsList.prepend(li); } };
                    swReset.onclick = () => resetSW(false);

                    container.querySelectorAll('.tab-button').forEach(btn => btn.onclick = () => { container.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); container.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none'); container.querySelector(`#${btn.dataset.tab}`).style.display = 'block'; if (btn.dataset.tab === 'timerTab') resetSW(true); else resetT(false); });
                    
                    resetT(true); resetSW(true);
                    return () => { clearInterval(tInt); clearInterval(swInt); };
                },
            };

            // --- Initial Tool Card Generation ---
            tools.forEach((tool, index) => {
                const card = document.createElement('div');
                card.className = 'tool-card';
                card.style.animationDelay = `${index * 0.05}s`;
                card.innerHTML = `<h2>${tool.title}</h2><p>${tool.description}</p><button class="tool-button" data-toolid="${tool.id}">Open Tool</button>`;
                card.querySelector('.tool-button').addEventListener('click', () => openModal(tool));
                toolGrid.appendChild(card);
            });
        });
    </script>
</body>
</html>